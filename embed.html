<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>US Map Embed</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #map-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        .tooltip {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }
        .tooltip-header {
            padding: 5px 10px;
            margin: -10px -10px 10px -10px;
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
            font-weight: bold;
            color: white;
            display: flex;
            align-items: center;
        }
        .state-icon {
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-size: 12px;
        }
        .tooltip-body {
            padding: 0 5px;
        }
        .legend {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .legend-title {
            text-align: center;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .legend-scale {
            height: 20px;
            width: 200px;
            margin-bottom: 5px;
        }
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="map-container"></div>
    <div id="tooltip" class="tooltip"></div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/uuid@8.3.2/dist/umd/uuid.min.js"></script>
    <script>
        // Get map ID from URL
        const urlParams = new URLSearchParams(window.location.search);
        const mapId = urlParams.get('id');

        if (!mapId) {
            document.getElementById('map-container').innerHTML = '<p style="text-align: center; margin-top: 50px;">No map ID provided</p>';
        } else {
            // Fetch map data
            fetch(`/api/get-map?id=${mapId}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to load map data');
                    }
                    return response.json();
                })
                .then(mapData => {
                    renderMap(mapData);
                })
                .catch(error => {
                    console.error('Error loading map data:', error);
                    document.getElementById('map-container').innerHTML = `<p style="text-align: center; margin-top: 50px;">Error loading map: ${error.message}</p>`;
                });
        }

        function renderMap(mapData) {
            const mapContainer = document.getElementById('map-container');
            const tooltip = document.getElementById('tooltip');
            
            // Set dimensions
            const width = mapContainer.clientWidth;
            const height = mapContainer.clientHeight;
            
            // Create SVG
            const svg = d3.select(mapContainer)
                .append('svg')
                .attr('width', '100%')
                .attr('height', '100%')
                .attr('viewBox', `0 0 ${width} ${height}`)
                .attr('preserveAspectRatio', 'xMidYMid meet');
            
            // Load US map data
            d3.json('https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json')
                .then(us => {
                    // Create projection
                    const projection = d3.geoAlbersUsa()
                        .fitSize([width, height], topojson.feature(us, us.objects.states));
                    
                    // Create path generator
                    const path = d3.geoPath().projection(projection);
                    
                    // Create color scale
                    let colorScale;
                    
                    if (mapData.colorScheme === 'multi') {
                        // For multi-color scheme, use a standard threshold scale
                        colorScale = d3.scaleThreshold()
                            .domain([25, 50, 75])
                            .range(['#388e3c', '#fbc02d', '#f57c00', '#d32f2f']); // Green, Yellow, Orange, Red
                    } else if (mapData.colorScheme === 'green-to-red') {
                        // Create a custom green to red color scale
                        colorScale = d3.scaleSequential()
                            .interpolator(d3.interpolateRgbBasis(['#388e3c', '#fbc02d', '#f57c00', '#d32f2f'])); // Green, Yellow, Orange, Red
                    } else {
                        // Sequential color schemes
                        colorScale = d3.scaleSequential();

                        switch (mapData.colorScheme) {
                            case 'blues':
                                colorScale.interpolator(d3.interpolateBlues);
                                break;
                            case 'greens':
                                colorScale.interpolator(d3.interpolateGreens);
                                break;
                            case 'reds':
                                colorScale.interpolator(d3.interpolateReds);
                                break;
                            case 'purples':
                                colorScale.interpolator(d3.interpolatePurples);
                                break;
                            case 'oranges':
                                colorScale.interpolator(d3.interpolateOranges);
                                break;
                            case 'viridis':
                                colorScale.interpolator(d3.interpolateViridis);
                                break;
                            default:
                                colorScale.interpolator(d3.interpolateBlues);
                        }
                    }
                    
                    // Find min and max values
                    let minValue = 0;
                    let maxValue = 100;

                    if (mapData.stateData && mapData.stateData.length > 0) {
                        const values = mapData.stateData
                            .filter(d => d.value !== null && d.value !== undefined)
                            .map(d => parseFloat(d.value));

                        if (values.length > 0) {
                            minValue = Math.min(...values);
                            maxValue = Math.max(...values);
                        }
                    }

                    // Set domain for color scale
                    colorScale.domain([minValue, maxValue]);
                    
                    // Create a map of state data for quick lookup
                    const stateDataMap = {};
                    if (mapData.stateData) {
                        mapData.stateData.forEach(state => {
                            stateDataMap[state.stateCode] = state;
                        });
                    }
                    
                    // Define small states that need special handling
                    const smallStates = ['RI', 'DE', 'DC', 'CT', 'NJ', 'MD', 'MA', 'NH', 'VT'];
                    
                    // Draw states
                    svg.selectAll('path')
                        .data(topojson.feature(us, us.objects.states).features)
                        .enter()
                        .append('path')
                        .attr('d', path)
                        .attr('fill', d => {
                            // Get state code
                            const stateId = d.id;
                            const stateInfo = getStateInfoFromId(stateId);
                            if (!stateInfo) return '#eee';
                            
                            const stateCode = stateInfo.code;
                            const stateData = stateDataMap[stateCode];
                            
                            // If we have data for this state
                            if (stateData && stateData.value !== null && stateData.value !== undefined) {
                                return colorScale(parseFloat(stateData.value));
                            }
                            
                            // No data for this state
                            return '#eee';
                        })
                        .attr('stroke', '#fff')
                        .attr('stroke-width', 0.5)
                        .attr('class', d => {
                            const stateInfo = getStateInfoFromId(d.id);
                            return stateInfo && smallStates.includes(stateInfo.code) ? 'small-state' : '';
                        })
                        .on('mouseover', (event, d) => {
                            const stateInfo = getStateInfoFromId(d.id);
                            if (!stateInfo) return;
                            
                            const stateCode = stateInfo.code;
                            const stateName = stateInfo.name;
                            const stateData = stateDataMap[stateCode];
                            
                            d3.select(event.currentTarget)
                                .attr('stroke', '#333')
                                .attr('stroke-width', 1.5);
                            
                            tooltip
                                .style('opacity', 1)
                                .style('left', `${event.pageX + 10}px`)
                                .style('top', `${event.pageY + 10}px`);
                            
                            // Determine color for tooltip header based on value
                            let headerColor = '#999';
                            if (stateData && stateData.value !== null && stateData.value !== undefined) {
                                const value = parseFloat(stateData.value);
                                const normalizedValue = (value - minValue) / (maxValue - minValue);
                                
                                if (normalizedValue >= 0.75) {
                                    headerColor = '#d32f2f'; // Red for highest values
                                } else if (normalizedValue >= 0.5) {
                                    headerColor = '#f57c00'; // Orange for high values
                                } else if (normalizedValue >= 0.25) {
                                    headerColor = '#fbc02d'; // Yellow for medium values
                                } else {
                                    headerColor = '#388e3c'; // Green for low values
                                }
                            }
                            
                            // Use the label as the header if available, otherwise use the state name
                            const headerText = stateData && stateData.label ? stateData.label : stateName;
                            
                            let tooltipContent = `
                                <div class="tooltip-header" style="background-color: ${headerColor}">
                                    <div class="state-icon">${stateCode}</div>
                                    ${headerText}
                                </div>
                                <div class="tooltip-body">`;
                            
                            if (stateData) {
                                // If we're using a label as the header, show the state name in the body
                                if (stateData.label) {
                                    tooltipContent += `<p><strong>State:</strong> ${stateName}</p>`;
                                }
                                
                                // Add info if available, preserving HTML formatting
                                if (stateData.info) {
                                    tooltipContent += `<p>${stateData.info}</p>`;
                                }
                            } else {
                                tooltipContent += '<p>No data available</p>';
                            }
                            
                            tooltipContent += '</div>';
                            
                            tooltip.html(tooltipContent);
                        })
                        .on('mousemove', (event) => {
                            tooltip
                                .style('left', `${event.pageX + 10}px`)
                                .style('top', `${event.pageY + 10}px`);
                        })
                        .on('mouseout', (event) => {
                            d3.select(event.currentTarget)
                                .attr('stroke', '#fff')
                                .attr('stroke-width', 0.5);
                            
                            tooltip.style('opacity', 0);
                        });
                    
                    // Add small states list to the side if enabled
                    if (mapData.showSmallStates !== false && smallStates.length > 0) {
                        // Create a group for the small states list
                        const smallStatesGroup = svg.append('g')
                            .attr('class', 'small-states-list')
                            .attr('transform', `translate(${width - 30}, ${height/2 - smallStates.length * 10})`);
                        
                        // Add each small state to the list
                        smallStates.forEach((stateCode, index) => {
                            const stateFeature = topojson.feature(us, us.objects.states).features
                                .find(d => {
                                    const stateInfo = getStateInfoFromId(d.id);
                                    return stateInfo && stateInfo.code === stateCode;
                                });
                            
                            if (!stateFeature) return;
                            
                            const stateCentroid = path.centroid(stateFeature);
                            
                            // Add small dot for the state
                            smallStatesGroup.append('circle')
                                .attr('cx', 0)
                                .attr('cy', index * 20)
                                .attr('r', 3)
                                .attr('fill', '#666');
                            
                            // Add state code text
                            smallStatesGroup.append('text')
                                .attr('x', 10)
                                .attr('y', index * 20 + 4)
                                .attr('font-size', '10px')
                                .attr('fill', '#333')
                                .attr('text-anchor', 'start')
                                .attr('alignment-baseline', 'middle')
                                .text(stateCode);
                            
                            // Draw connecting line from list to state - curved line
                            if (stateCentroid && stateCentroid.length === 2) {
                                // Calculate the position relative to the smallStatesGroup
                                const targetX = stateCentroid[0] - (width - 30);
                                const targetY = stateCentroid[1] - (height/2 - smallStates.length * 10);
                                
                                // Create a curved path using SVG path commands
                                const path = `M 0 ${index * 20} L -10 ${index * 20} Q -30 ${index * 20} ${targetX} ${targetY}`;
                                
                                smallStatesGroup.append('path')
                                    .attr('d', path)
                                    .attr('fill', 'none')
                                    .attr('stroke', '#ccc')
                                    .attr('stroke-width', 0.5);
                            }
                        });
                    }
                    
                    // Add state labels if enabled
                    if (mapData.showLabels) {
                        svg.selectAll('text.state-label')
                            .data(topojson.feature(us, us.objects.states).features)
                            .enter()
                            .append('text')
                            .attr('class', 'state-label')
                            .attr('x', d => {
                                const centroid = path.centroid(d);
                                return centroid[0];
                            })
                            .attr('y', d => {
                                const centroid = path.centroid(d);
                                return centroid[1];
                            })
                            .attr('text-anchor', 'middle')
                            .attr('alignment-baseline', 'middle')
                            .attr('font-size', '8px')
                            .attr('fill', '#333')
                            .text(d => {
                                const stateInfo = getStateInfoFromId(d.id);
                                return stateInfo ? stateInfo.code : '';
                            });
                    }
                    
                    // Add legend if we have data
                    if (mapData.stateData && mapData.stateData.length > 0) {
                        const legendWidth = 200;
                        const legendHeight = 20;
                        // Position the legend to the right side of the map, between Texas and Florida
                        const legendX = width * 0.58; // Moved a tiny bit more to the left
                        const legendY = height - 40; // Very close to the bottom
                        
                        // Create legend group
                        const legend = svg.append('g')
                            .attr('class', 'legend')
                            .attr('transform', `translate(${legendX}, ${legendY})`);
                        
                        // Add legend title
                        legend.append('text')
                            .attr('class', 'legend-title')
                            .attr('x', legendWidth / 2)
                            .attr('y', -10)
                            .attr('text-anchor', 'middle')
                            .attr('font-size', '12px')
                            .text(mapData.legendTitle || 'Legend');
                        
                        // Create gradient for legend
                        const defs = svg.append('defs');
                        const gradient = defs.append('linearGradient')
                            .attr('id', 'legend-gradient')
                            .attr('x1', '0%')
                            .attr('x2', '100%')
                            .attr('y1', '0%')
                            .attr('y2', '0%');
                        
                        // Add color stops
                        const numStops = 10;
                        for (let i = 0; i <= numStops; i++) {
                            const offset = `${i * 100 / numStops}%`;
                            const value = minValue + (i / numStops) * (maxValue - minValue);
                            gradient.append('stop')
                                .attr('offset', offset)
                                .attr('stop-color', colorScale(value));
                        }
                        
                        // Draw legend rectangle
                        legend.append('rect')
                            .attr('width', legendWidth)
                            .attr('height', legendHeight)
                            .style('fill', 'url(#legend-gradient)')
                            .attr('stroke', '#ccc')
                            .attr('stroke-width', 1);
                        
                        // Add min label
                        legend.append('text')
                            .attr('x', 0)
                            .attr('y', legendHeight + 15)
                            .attr('font-size', '12px')
                            .attr('fill', '#000')
                            .attr('font-weight', 'bold')
                            .text(mapData.legendMinLabel || minValue.toString());
                        
                        // Add max label
                        legend.append('text')
                            .attr('x', legendWidth)
                            .attr('y', legendHeight + 15)
                            .attr('font-size', '12px')
                            .attr('fill', '#000')
                            .attr('text-anchor', 'end')
                            .attr('font-weight', 'bold')
                            .text(mapData.legendMaxLabel || maxValue.toString());
                    }
                    
                    // Add title if provided
                    if (mapData.title) {
                        svg.append('text')
                            .attr('x', width / 2)
                            .attr('y', 30)
                            .attr('text-anchor', 'middle')
                            .attr('font-size', '16px')
                            .attr('font-weight', 'bold')
                            .attr('fill', '#333')
                            .text(mapData.title);
                    }
                })
                .catch(error => {
                    console.error('Error loading US map data:', error);
                    mapContainer.innerHTML = `<p style="text-align: center; margin-top: 50px;">Error loading US map data: ${error.message}</p>`;
                });
        }

        // Helper function to get state info from ID
        function getStateInfoFromId(id) {
            // Map of state IDs to state codes and names
            const stateMap = {
                "01": { code: "AL", name: "Alabama" },
                "02": { code: "AK", name: "Alaska" },
                "04": { code: "AZ", name: "Arizona" },
                "05": { code: "AR", name: "Arkansas" },
                "06": { code: "CA", name: "California" },
                "08": { code: "CO", name: "Colorado" },
                "09": { code: "CT", name: "Connecticut" },
                "10": { code: "DE", name: "Delaware" },
                "11": { code: "DC", name: "District of Columbia" },
                "12": { code: "FL", name: "Florida" },
                "13": { code: "GA", name: "Georgia" },
                "15": { code: "HI", name: "Hawaii" },
                "16": { code: "ID", name: "Idaho" },
                "17": { code: "IL", name: "Illinois" },
                "18": { code: "IN", name: "Indiana" },
                "19": { code: "IA", name: "Iowa" },
                "20": { code: "KS", name: "Kansas" },
                "21": { code: "KY", name: "Kentucky" },
                "22": { code: "LA", name: "Louisiana" },
                "23": { code: "ME", name: "Maine" },
                "24": { code: "MD", name: "Maryland" },
                "25": { code: "MA", name: "Massachusetts" },
                "26": { code: "MI", name: "Michigan" },
                "27": { code: "MN", name: "Minnesota" },
                "28": { code: "MS", name: "Mississippi" },
                "29": { code: "MO", name: "Missouri" },
                "30": { code: "MT", name: "Montana" },
                "31": { code: "NE", name: "Nebraska" },
                "32": { code: "NV", name: "Nevada" },
                "33": { code: "NH", name: "New Hampshire" },
                "34": { code: "NJ", name: "New Jersey" },
                "35": { code: "NM", name: "New Mexico" },
                "36": { code: "NY", name: "New York" },
                "37": { code: "NC", name: "North Carolina" },
                "38": { code: "ND", name: "North Dakota" },
                "39": { code: "OH", name: "Ohio" },
                "40": { code: "OK", name: "Oklahoma" },
                "41": { code: "OR", name: "Oregon" },
                "42": { code: "PA", name: "Pennsylvania" },
                "44": { code: "RI", name: "Rhode Island" },
                "45": { code: "SC", name: "South Carolina" },
                "46": { code: "SD", name: "South Dakota" },
                "47": { code: "TN", name: "Tennessee" },
                "48": { code: "TX", name: "Texas" },
                "49": { code: "UT", name: "Utah" },
                "50": { code: "VT", name: "Vermont" },
                "51": { code: "VA", name: "Virginia" },
                "53": { code: "WA", name: "Washington" },
                "54": { code: "WV", name: "West Virginia" },
                "55": { code: "WI", name: "Wisconsin" },
                "56": { code: "WY", name: "Wyoming" }
            };
            
            return stateMap[id];
        }
    </script>
</body>
</html>
